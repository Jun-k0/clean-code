



### 동시성이 필요한 이유?

작업을 빠르게 처리하여 속도를 올리기 위하여 필요합니다.

하지만 **미신과 오해**가 많이들 생깁니다.

- 동시성은 항상 성능을 높여준다. -> 때로 성능을 높여준다.
- 동시성을 구현해도 설계는 변하지 않는다 -> 구조가 크게 달라진다.
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다. -> 있음. 

그리고 타당한 몇가지 생각들이 있습니다

- 동시성은 다소 부하를 유발한다.
- 동시성은 복잡하다.ㅏ
- 일반적으로 동시성 버그는 재현하기 어렵다.
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다. 

### 난관 

동시성을 구현하게 되면 잘못된 결과를 내놓는 **일부**때문에 구현하기가 어렵습니다. 

### 동시성 방어 원칙

그래서 동시성 코드가 일으키는 코문제로부터 시스템을 방어하는 원칙과 기술을 소개합니다.

- 단일 책임 원칙 (SRP)
  - 동시성은 복잡성 하나만으로도 따로 분리할 이유가 충분합니다. 
  - **동시성 코드는 다른 코드와 분리해야 합니다!**
- 따름 정리 : 자료 범위를 제한하라 
  - 두 쓰레드 간에 간섭이 있다면 예상치 못한 결과가 나옵니다. 
  - 따라서 공유 객체를 사용하는 코드 내 임계영역을 보호해야 합니다.
  - **자료를 캡슐화하라. 공유 자료를 최대한 줄여라!**
- 따름 정리 : 자료 사본을 사용하라 
  - 공유 객체를 복사해서 만들어 원본 객첵의 변경을 피합니다.
- 따름 정리 : 스레드는 가능한 독립적으로 구현하라 
  - 애초에 공유 객체를 만들지 맙시다!

### 실행 모델을 이해하라

- 다중 스레드 애플리케이션 분류 방식 

  | 용어        | 설명                                                         |
  | ----------- | ------------------------------------------------------------ |
  | 한정된 자원 | 다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다. |
  | 상호 배제   | 한번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다. |
  | 기아        | 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다. |
  | 데드락      | 여러 스레드가 서로가 끝나기를 기다린다. 어느 쪽도 진행되지 못하는 상황 |
  | 라이브락    | 락을 거는 단계에서 각 스레드가 서로를 방해한다.              |

- 실행 모델 

  **생산자 - 소비자**

  -  생상자 스레드가 정보를 생성해 **버퍼**에 넣는다. 소비자 스레드는 버퍼에서 정보를 가져와 사용한다.
  - 이 **버퍼**는 한정된 자원이다. 생상자 스레드는 버퍼에 빈 공간이 있어야 정보를 채운다. 즉, 빈 공간이 생길 때까지 기다린다. 반대로 소비자 스레드는 버퍼에 빈 공간이 생길 때까지 기다린다. 

  **읽기-쓰기**

  - 읽기 스레드를 위한 주된 정보원으로 공유 자원을 사용하지만, 쓰기 스레드가 이 공유 자원을 이따금 갱신한다고 하자. 
  - 이 때 처리율, 즉 읽기를 더욱 강조하면 기아 현상이 생겨 오래된 정보가 쌓이고 갱신을 허용하면 처리율에 영양을 미친다.
  - 처리율과 갱신 둘 다 만족시킬 방식이 필요하다.

  **식사하는 철학자들**

  - 둥근 식탁에 철학자 한 무리가 둘러앉았다. .... 이건 OS시간에 자주 나오는 예제로 설명은 생략!

**동기화하는 메서드 사이에 존재하는 의존성을 이해하라** 

- 동기화하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다. 즉, 공유 객체의 메서드는 조심해야한다.
- **공유 객체 하나에는 메서드 하나만 사용하라**
- 여러가지 메서드를 사용해야 할 경우 아래 규칙을 따른다.
  - 클라이언트에서 잠금 처리 - 첫 번째 메서드를 호출하기 전에 서버를 잠근다(?????). 마지막 메서드를 호출할 때까지 잠금을 유지한다.
  - 서버에서 잠금 처리 - 서버에다 "서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는" 메서드를 구현한다. 
  - 연결 서버 - 잠금을 구행하는 중간 단계를 생성한다. 

### 동기화하는 부분을 작게 만들어라 

### 올바른 종료 코드는 구현하기 어렵다

데드락이 흔히 발생하는 문제입니다. 스레드가 절대 오지 않을 시그널을 기다리는 문제입니다. 그러므로 깔끔하게 종료하는 다중 스레드 코드를 짜야 한다면 시간을 투자해 올바로 구현하기 바랍니다.

### 스레드 코드 테스트하기

- 문제를 노출하는 테스트 케이스를 작성하라 
- 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려라 
- 테스트가 실패하면 원인을 추적하라. 다시 돌렸더니 통과하더라는 이유로 그냥 넘어가면 절대로 안 된다!!!

아래는 각각 테스트하는 방식에 대한 설명입니다.

*만이 안되는 실패는 잠정적인 스레드 문제로 취급하라*

*다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자*

*다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라*

*다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라*

*프로세서 수보다 많은 스레드를 둘러보라*

*다른 플랫폼에서 돌려보라*

*코드에 보조코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라*

- 코드가 실행되는 순서가 바뀌게끔 만드는 보조코드를 삽입해서 테스트해본다. 
  - wait(), sleep(), yield(), priority() 함수를 추가하여 직접 구현할 수 있다. 
  - AOF, CGLIB, ASM 등과 같은 도구(하나도 모르겟음)를 사용해 자동으로 보조코드를 추가할 수 있다.

### 결론 

다중 스레드 코드는 올바로 구현하기 어렵습니다. 위 내용만 보아도 생각할 거리가 정말 많은 것을 알 수 있습니다. 특히 주의하지 않으면 희귀하고 오묘한 오류에 직면하게 됩니다. 무엇보다 SRP를 준수해야 합니다. 즉, 스레드는 최대한 집약되고 작아야 한다는 의미입니다. 사용하는 라이브러리와 기본 알고리즘, 특정 코드 영역을 잠그는 방법 등에 대해 확실히 이해하고 구현해야 합니다.

어떻게든 문제는 생깁니다. 초반에 드러나지 않는 문제는 일회성으로 치부해 무시하기 십상입니다. 그러므로 많은 플랫폼에서 많은 설정으로 반복해서 계속 테스트해야 합니다. 

